import sys
import signal
import os
import time
import subprocess

# --- âš ï¸ PARCHE CRÃTICO PARA WINDOWS (ESTO DEBE IR PRIMERO) âš ï¸ ---
# Definimos las seÃ±ales Unix que faltan en Windows ANTES de importar CrewAI
if sys.platform.startswith('win'):
    def _patch_signal(sig_name):
        if not hasattr(signal, sig_name):
            # Asignamos un valor dummy para engaÃ±ar a la librerÃ­a
            setattr(signal, sig_name, signal.SIGTERM if hasattr(signal, 'SIGTERM') else 1)

    # Lista de seÃ±ales que CrewAI/LangChain podrÃ­an buscar
    unix_signals = ['SIGHUP', 'SIGQUIT', 'SIGTRAP', 'SIGIOT', 'SIGBUS', 'SIGFPE', 
                    'SIGUSR1', 'SIGSEGV', 'SIGUSR2', 'SIGPIPE', 'SIGALRM', 'SIGTERM',
                    'SIGCHLD', 'SIGCONT', 'SIGSTOP', 'SIGTSTP', 'SIGTTIN', 'SIGTTOU', 
                    'SIGURG', 'SIGXCPU', 'SIGXFSZ', 'SIGVTALRM', 'SIGPROF', 'SIGWINCH', 
                    'SIGIO', 'SIGPWR', 'SIGSYS']
    
    for sig in unix_signals:
        _patch_signal(sig)

# --- AHORA SÃ IMPORTAMOS LAS LIBRERÃAS PESADAS ---
from github import Github
from crewai import Agent, Task, Crew, Process
from langchain_google_genai import ChatGoogleGenerativeAI
from dotenv import load_dotenv
from crewai_tools import FileWriterTool, FileReadTool

load_dotenv()

# --- CONFIGURACIÃ“N GITHUB ---
# AsegÃºrate de tener estas variables en tu .env
GITHUB_TOKEN = os.getenv("GITHUB_TOKEN")
REPO_NAME = os.getenv("GITHUB_REPO_NAME") 

# ValidaciÃ³n simple para no fallar mÃ¡s tarde
if not GITHUB_TOKEN or not REPO_NAME:
    print("âŒ ERROR: Faltan GITHUB_TOKEN o GITHUB_REPO_NAME en el archivo .env")
    sys.exit(1)

try:
    g = Github(GITHUB_TOKEN)
except Exception as e:
    print(f"âŒ Error conectando a GitHub: {e}")
    sys.exit(1)

# --- CONFIGURACIÃ“N DEL CEREBRO ---
llm = ChatGoogleGenerativeAI(
    model="gemini-pro-latest", 
    verbose=True,
    temperature=0.1,
    google_api_key=os.getenv("GOOGLE_API_KEY"),
    max_retries=10,
    request_timeout=120
)

# --- HERRAMIENTAS ---

# 1. Herramienta Escritura UTF-8 (Hack para Docker/Windows)
class UTF8FileWriterTool(FileWriterTool):
    name: str = "Save File UTF-8"
    description: str = "Saves content to a file using UTF-8 encoding. Input: filename, content."
    def _run(self, filename: str, content: str, **kwargs) -> str:
        try:
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(content)
            return f"File {filename} saved successfully."
        except Exception as e:
            return f"Error saving: {e}"

file_writer = UTF8FileWriterTool()

# 2. Herramienta Lectura (Para tener contexto)
file_reader = FileReadTool()

# --- FUNCIONES DE GESTIÃ“N GITHUB ---

def get_ai_tasks():
    """Busca Issues abiertas con la etiqueta 'ai-agent'"""
    try:
        repo = g.get_repo(REPO_NAME)
        issues = repo.get_issues(state='open', labels=['ai-agent'])
        return issues
    except Exception as e:
        print(f"âš ï¸ Error leyendo issues: {e}")
        return []

def create_pull_request(issue_number, issue_title):
    """Crea una PR con los cambios"""
    print(f"ğŸš€ Creando Pull Request para Issue #{issue_number}...")
    try:
        current_dir = os.getcwd()
        branch_name = f"feature/issue-{issue_number}"
        
        # Git commands wrapper
        subprocess.run(f"git checkout -b {branch_name}", shell=True, cwd=current_dir)
        subprocess.run("git add .", shell=True, cwd=current_dir)
        subprocess.run(f'git commit -m "AI Fix: {issue_title}"', shell=True, cwd=current_dir)
        subprocess.run(f"git push origin {branch_name}", shell=True, cwd=current_dir)
        
        # GitHub API call
        repo = g.get_repo(REPO_NAME)
        body = f"Resolves #{issue_number}\n\nGenerated by Autonomous AI Agent ğŸ¤–"
        pr = repo.create_pull(title=f"AI Implementation: {issue_title}", body=body, head=branch_name, base="main")
        
        print(f"âœ… PR Creada: {pr.html_url}")
        
        # Volver a main
        subprocess.run("git checkout main", shell=True, cwd=current_dir)
        return True
    except Exception as e:
        print(f"âŒ Error creando PR: {e}")
        # Intentar volver a main por si acaso
        subprocess.run("git checkout main", shell=True) 
        return False

# --- EL CICLO DE DESARROLLO (AGENTS) ---

def run_development_cycle(issue_body):
    
    # Definimos agentes aquÃ­ para que estÃ©n "frescos" en cada tarea
    po = Agent(
        role='Product Owner',
        goal='Analyze code and requirements.',
        backstory='Expert PO. Reads files to understand context.',
        llm=llm,
        verbose=True,
        tools=[file_reader]
    )

    dev = Agent(
        role='Developer',
        goal='Modify code without breaking existing features.',
        backstory='Expert Python dev.',
        llm=llm,
        verbose=True,
        tools=[file_reader, file_writer]
    )

    qa = Agent(
        role='QA Engineer',
        goal='Create robust tests.',
        backstory='Expert QA.',
        llm=llm,
        verbose=True,
        tools=[file_writer]
    )

    # Tareas
    task_analysis = Task(
        description=f"1. Read 'calculator.py' (if exists). 2. Analyze GitHub requirement: '{issue_body}'. 3. Create a plan.",
        agent=po,
        expected_output="Plan."
    )

    task_code = Task(
        description="Implement feature in 'calculator.py' using UTF-8 tool. Keep existing logic.",
        agent=dev,
        expected_output="File saved."
    )

    task_test = Task(
        description="Update 'test_calculator.py' using mock_open logic.",
        agent=qa,
        expected_output="File saved."
    )

    crew = Crew(
        agents=[po, dev, qa],
        tasks=[task_analysis, task_code, task_test],
        verbose=True,
        process=Process.sequential,
        max_rpm=2
    )

    return crew.kickoff()

# --- BUCLE PRINCIPAL ---

if __name__ == "__main__":
    print("==========================================")
    print(f"ğŸ‘€ VIGILANTE ACTIVO EN: {REPO_NAME}")
    print("Esperando issues con etiqueta 'ai-agent'...")
    print("==========================================")

    while True:
        try:
            issues = get_ai_tasks()
            
            # Verificamos si hay issues (issues es un iterador paginado, count es lo seguro)
            if issues.totalCount > 0:
                for issue in issues:
                    print(f"\nğŸ”” NUEVA TAREA: {issue.title}")
                    print(f"ğŸ“ Requisitos: {issue.body}")
                    
                    print("ğŸ¤– Trabajando...")
                    run_development_cycle(issue.body)
                    
                    print("ğŸ§ª Ejecutando Tests Docker...")
                    # EjecuciÃ³n robusta de Docker
                    cmd = f'docker run --rm -v "{os.getcwd()}":/app -w /app python:3.10-slim python -m unittest test_calculator.py'
                    result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
                    
                    if result.returncode == 0:
                        print("âœ… Tests OK.")
                        if create_pull_request(issue.number, issue.title):
                            issue.create_comment(f"Trabajo completado. PR Creada. âœ…")
                    else:
                        print("âŒ Fallo en tests.")
                        issue.create_comment(f"Hubo errores en los tests:\n```\n{result.stderr}\n```")

                    print("ğŸ’¤ Pausa de seguridad...")
                    time.sleep(10)
            else:
                sys.stdout.write(".")
                sys.stdout.flush()
                time.sleep(30) # Revisar cada 30 segundos
                
        except KeyboardInterrupt:
            print("\nğŸ›‘ Deteniendo el equipo IA.")
            break
        except Exception as e:
            print(f"\nâŒ Error en el bucle: {e}")
            time.sleep(30)
