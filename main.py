import sys
import signal
import os
import time
import subprocess

# --- âš ï¸ PARCHE CRÃTICO PARA WINDOWS âš ï¸ ---
if sys.platform.startswith('win'):
    def _patch_signal(sig_name):
        if not hasattr(signal, sig_name):
            setattr(signal, sig_name, signal.SIGTERM if hasattr(signal, 'SIGTERM') else 1)

    unix_signals = ['SIGHUP', 'SIGQUIT', 'SIGTRAP', 'SIGIOT', 'SIGBUS', 'SIGFPE', 
                    'SIGUSR1', 'SIGSEGV', 'SIGUSR2', 'SIGPIPE', 'SIGALRM', 'SIGTERM',
                    'SIGCHLD', 'SIGCONT', 'SIGSTOP', 'SIGTSTP', 'SIGTTIN', 'SIGTTOU', 
                    'SIGURG', 'SIGXCPU', 'SIGXFSZ', 'SIGVTALRM', 'SIGPROF', 'SIGWINCH', 
                    'SIGIO', 'SIGPWR', 'SIGSYS']
    for sig in unix_signals:
        _patch_signal(sig)

# --- IMPORTACIONES ---
from github import Github
from crewai import Agent, Task, Crew, Process
from langchain_google_genai import ChatGoogleGenerativeAI
from dotenv import load_dotenv
# ğŸ‘‡ SOLO IMPORTAMOS LO QUE SABEMOS QUE FUNCIONA
from crewai_tools import FileWriterTool, FileReadTool 

load_dotenv()

# --- CONFIGURACIÃ“N ---
GITHUB_TOKEN = os.getenv("GITHUB_TOKEN")
REPO_NAME = os.getenv("GITHUB_REPO_NAME") 

if not GITHUB_TOKEN or not REPO_NAME:
    print("âŒ ERROR: Faltan variables en .env")
    sys.exit(1)

g = Github(GITHUB_TOKEN)

llm = ChatGoogleGenerativeAI(
    model="gemini-pro-latest", 
    verbose=True,
    temperature=0.1,
    google_api_key=os.getenv("GOOGLE_API_KEY"),
    max_retries=10,
    request_timeout=120
)

# --- HERRAMIENTAS PERSONALIZADAS (HACK DE HERENCIA) ---

# 1. Herramienta Escritura UTF-8
class UTF8FileWriterTool(FileWriterTool):
    name: str = "Save File UTF-8"
    description: str = "Saves content to a file using UTF-8 encoding."
    def _run(self, filename: str, content: str, **kwargs) -> str:
        try:
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(content)
            return f"File {filename} saved successfully."
        except Exception as e:
            return f"Error saving: {e}"

# 2. Herramienta Lectura Inteligente (NUEVA)
# Heredamos de FileReadTool porque sabemos que esa clase sÃ­ la tienes bien importada
# 2. Herramienta Lectura Inteligente (CORREGIDA)
class SmartFileLister(FileReadTool):
    name: str = "List Project Files"
    # ğŸ‘‡ CAMBIO CLAVE: En la descripciÃ³n obligamos al agente a enviar un parÃ¡metro dummy
    description: str = "Lists relevant files in the current directory. IMPORTANT: You MUST provide a 'file_path' argument (use file_path='.'), otherwise the tool will fail."

    # ğŸ‘‡ CAMBIO CLAVE: Aceptamos el argumento file_path para que Pydantic no se queje
    def _run(self, file_path: str = '.', **kwargs) -> str:
        # Ignoramos file_path, pero lo recibimos para que no de error
        ignored_folders = {'.git', 'venv', 'env', '__pycache__', '.idea', '.vscode', 'git'}
        files = []
        try:
            for item in os.listdir('.'):
                if item not in ignored_folders and not item.startswith('.'):
                    files.append(item)
            
            if not files:
                return "Directory is empty."
            return "\n".join(files)
        except Exception as e:
            return f"Error listing files: {str(e)}"

# Instanciamos las herramientas
file_writer = UTF8FileWriterTool()
file_reader = FileReadTool()
smart_directory_reader = SmartFileLister() # <--- Nuestra nueva herramienta filtrada

# --- FUNCIONES AUXILIARES ---

def get_ai_tasks():
    try:
        repo = g.get_repo(REPO_NAME)
        issues = repo.get_issues(state='open', labels=['ai-agent'])
        return issues
    except Exception as e:
        print(f"âš ï¸ Error leyendo issues: {e}")
        return []

def create_pull_request(issue_number, issue_title):
    print(f"ğŸš€ Creando Pull Request para Issue #{issue_number}...")
    try:
        current_dir = os.getcwd()
        branch_name = f"feature/issue-{issue_number}"
        
        subprocess.run(f"git checkout -b {branch_name}", shell=True, cwd=current_dir)
        subprocess.run("git add .", shell=True, cwd=current_dir)
        subprocess.run(f'git commit -m "AI Fix: {issue_title}"', shell=True, cwd=current_dir)
        subprocess.run(f"git push origin {branch_name}", shell=True, cwd=current_dir)
        
        repo = g.get_repo(REPO_NAME)
        body = f"Resolves #{issue_number}\n\nGenerated by Autonomous AI Agent ğŸ¤–"
        pr = repo.create_pull(title=f"AI Implementation: {issue_title}", body=body, head=branch_name, base="main")
        
        print(f"âœ… PR Creada: {pr.html_url}")
        subprocess.run("git checkout main", shell=True, cwd=current_dir)
        return True
    except Exception as e:
        print(f"âŒ Error creando PR: {e}")
        subprocess.run("git checkout main", shell=True) 
        return False

def run_docker_tests():
    print("ğŸ§ª Ejecutando Tests en Docker...")
    cmd = f'docker run --rm -v "{os.getcwd()}":/app -w /app python:3.10-slim python -m unittest test_calculator.py'
    result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
    
    if result.returncode == 0:
        return True, result.stderr
    else:
        return False, result.stderr

# --- LÃ“GICA DE RESOLUCIÃ“N ---

def solve_issue_with_retries(issue):
    MAX_RETRIES = 3
    attempt = 0
    
    # Instanciamos la herramienta actualizada
    smart_reader_instance = SmartFileLister() 

    # AGENTES
    po = Agent(
        role='Product Owner', 
        goal='Analyze requirements.', 
        backstory='Expert PO.', 
        llm=llm, 
        verbose=True, 
        tools=[smart_reader_instance, file_reader] # Usamos la instancia nueva
    )
    
    dev = Agent(role='Developer', goal='Write robust code.', backstory='Expert Python dev.', llm=llm, verbose=True, tools=[file_reader, file_writer])
    qa = Agent(role='QA Engineer', goal='Write tests.', backstory='Expert QA.', llm=llm, verbose=True, tools=[file_writer])

    # FASE 1
    print("ğŸ¤– Iniciando ciclo de desarrollo...")
    
    # Actualizamos el Prompt para recordarle al agente que ponga el argumento dummy
    task_analysis = Task(
        description=f"""
        1. USE tool 'List Project Files' (remember to provide file_path='.') to see what files exist.
        2. READ 'calculator.py' (if it exists in the list).
        3. Analyze GitHub issue: '{issue.body}'.
        4. Create a plan respecting existing code.
        """,
        agent=po,
        expected_output="Technical Plan."
    )

    task_code = Task(
        description="Implement code in 'calculator.py'. Use UTF-8 tool.",
        agent=dev,
        expected_output="File saved."
    )

    task_test = Task(
        description="Update 'test_calculator.py' using mock_open logic.",
        agent=qa,
        expected_output="File saved."
    )

    crew = Crew(agents=[po, dev, qa], tasks=[task_analysis, task_code, task_test], verbose=True, process=Process.sequential, max_rpm=2)
    crew.kickoff()

    # FASE 2: AUTO-CORRECCIÃ“N
    while attempt < MAX_RETRIES:
        print(f"\nğŸ”„ ValidaciÃ³n {attempt + 1}/{MAX_RETRIES}...")
        tests_passed, error_log = run_docker_tests()
        
        if tests_passed:
            print("âœ… Tests pasados.")
            return True, None
        else:
            print(f"âŒ Fallo en Tests. Reparando...")
            attempt += 1
            if attempt < MAX_RETRIES:
                fix_task = Task(
                    description=f"Tests FAILED:\n{error_log}\n\nFIX the code in calculator.py or test_calculator.py.",
                    agent=dev,
                    expected_output="Files fixed."
                )
                fix_crew = Crew(agents=[dev], tasks=[fix_task], verbose=True, max_rpm=2)
                fix_crew.kickoff()
            
    return False, error_log

# --- BUCLE PRINCIPAL ---

if __name__ == "__main__":
    print("==========================================")
    print(f"ğŸ‘€ VIGILANTE ACTIVO EN: {REPO_NAME}")
    print("  - Modo: Auto-Healing + Smart Filter")
    print("==========================================")

    while True:
        try:
            issues = get_ai_tasks()
            
            if issues.totalCount > 0:
                for issue in issues:
                    print(f"\nğŸ”” TAREA DETECTADA: {issue.title} (#{issue.number})")
                    
                    success, final_error = solve_issue_with_retries(issue)
                    
                    if success:
                        if create_pull_request(issue.number, issue.title):
                            issue.create_comment("âœ… Trabajo completado. PR Creada.")
                            print(f"ğŸ—‘ï¸ Eliminando etiqueta 'ai-agent'...")
                            issue.remove_from_labels("ai-agent")
                    else:
                        print("ğŸ’€ Se acabaron los intentos.")
                        issue.create_comment(f"âŒ Fallo tras intentos. Error:\n```\n{final_error}\n```")
                        issue.remove_from_labels("ai-agent")
                        issue.add_to_labels("help-wanted")

                    print("ğŸ’¤ Descansando...")
                    time.sleep(10)
            else:
                sys.stdout.write(".")
                sys.stdout.flush()
                time.sleep(30)
                
        except KeyboardInterrupt:
            break
        except Exception as e:
            print(f"\nâŒ Error General: {e}")
            time.sleep(30)